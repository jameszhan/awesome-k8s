

```bash
$ netstat -anptu
```

- CLOSED：无活动的或正在进行的连接。
- LISTEN：服务器正在等待进入呼叫。
- SYN_RECV：一个连接请求已经到达，等待确认。
- SYN_SENT：应用已经开始，打开一个连接。
- ESTABLISHED：正常数据传输状态。
- FIN_WAIT1：应用说它已经完成。
- FIN_WAIT2：另一边已同意释放。
- ITMED_WAIT：等待所有分组死掉。
- CLOSING：两边尝试同时关闭。
- TIME_WAIT：另一边已初始化一个释放。
- LAST_ACK：等待所有分组死掉


#### TCP连接状态
- CLOSED：这个没什么好说的，表示初始状态。
- LISTEN：这也是非常容易理解的一个状态，表示服务器端的某个Socket正处于监听状态，可以接收连接了。
- SYN_RCVD：这个状态表示接收到了SYN报文，在正常情况下，这个状态是服务器端的Socket在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，用netstat命令基本上是很难看到这种状态的，除非特意编写一个客户端测试程序，故意将TCP三次握手过程中的最后一个ACK报文不予发送。在正常情况下，当收到客户端的ACK报文时，它会进入到ESTABLISHED状态。
- SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端Socket执行CONNECT连接时，它首先会发送SYN报文，随即进入SYN_SENT状态，并等待服务端发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送了SYN报文。
- ESTABLISHED：这个很容易理解，表示连接已经建立了。
- FIN_WAIT_1：这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都表示正在等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当Socket在ESTABLISHED状态时，它想主动关闭连接，于是向对方发送了FIN报文，然后该Socket就进入到FIN_WAIT_1状态了。而在对方回应ACK报文后，则进入FIN_WAIT_2状态，当然在实际的正常情况下，无论对方处于何种情况，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是很难看到的，而FIN_WAIT_2状态还是常常可以用netstat看到的。
- FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的Socket，表示半连接，即有一方要求关闭连接，同时还会告诉对方，我暂时还有点数据需要传送给你，稍后将关闭连接。
- TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到了对方同时带有FIN标志和ACK标志的报文，就可以直接进入到TIME_WAIT状态了，而无须经过FIN_WAIT_2状态。
- CLOSING：这种状态比较特殊，在实际应用中应该很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文时，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，而是收到了对方的FIN报文。在什么情况下会出现此状况呢？其实细想一下，也不难得出结论：如果双方几乎在同时关闭一个Socket的话，那么就会出现双方同时发送FIN报文的情况，也就会出现CLOSING状态，表示双方都正在关闭Socket连接。
- CLOSE_WAIT：这种状态的含义其实是表示正在等待关闭。怎么理解呢？当对方关闭一个Socket后发送FIN报文给自己，系统会毫无疑问地回应一个ACK报文给对方，此时就会进入到CLOSE_WAIT状态。实际上接下来你真正需要考虑的事情是，查看你是否还有数据要发送给对方，如果没有的话，那么你就可以关闭这个Socket，发送FIN报文给对方，即关闭连接了。所以在CLOSE_WAIT的状态下，需要完成的事情是等待，然后关闭连接。
- LAST_ACK：这个状态还是比较好理解的，它是被动关闭的一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文时，就表示可以进入CLOSED可用状态了。