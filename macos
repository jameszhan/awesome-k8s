#!/usr/bin/env ruby
require 'thor'
require 'sshkit'
require 'sshkit/sudo'
require 'sshkit/dsl'

SSHKit.config.format = :pretty
SSHKit.config.output_verbosity = :debug

SUDO_USER = ENV['SUDO_USER']
SUDO_PASS = ENV['SUDO_PASS']

class Runner
  include Thor::Base

  def self.batch(&block)
    runner = Runner.new
    runner.instance_eval(&block)
    runner.execute
  end

  def initialize(config = {}, &block)
    @config = config
    instance_eval(&block) if block_given?
  end

  def scripts
    @scripts ||= []
  end

  def run(command, config = {})
    say_status :run, command, config.fetch(:verbose, true)
    scripts << command
  end

  def execute
    command = scripts.join(' && ')
    return if @config[:'dry-run']
    @config[:capture] ? `#{command}` : system(command)
  end
end

class PasswordInteractionHandler

  def on_data(command, stream_name, data, channel)
    case data
      when /password/i
        channel.send_data("#{SUDO_PASS}\n")
      else
        puts "#{command}, #{stream_name}, #{data}, #{channel}"
        channel.send_data("#{SUDO_PASS}\n")
    end
  end

end

class MacOS < Thor
  include Actions
  include SSHKit::DSL

  desc 'setup 192.168.64.7 ubuntu', 'setup for 192.168.64.7 via user ubuntu'
  def setup(hostip, username='ubuntu', port=22)
    on "#{username}@#{hostip}:#{port}", in: :sequence, wait: 5 do
      sudo :apt, 'install', '-yq', '--no-install-recommends', 'coreutils procps libseccomp2 net-tools sysstat rsync bash-completion socat'

      execute :echo, 'export LC_ALL=en_US.UTF-8', '>> ~/.bashrc' if test '[ -z $LC_ALL ]'
      execute :echo, 'export LANG=en_US.UTF-8', '>> ~/.bashrc' if test '[ -z $LANG ]'

      unless test('type chronyd')
        sudo 'apt -yq remove ntpd' if test('type ntpd')
        sudo 'apt -yq update'
        sudo 'apt -yq install chrony'

        sudo 'timedatectl set-timezone Asia/Shanghai'
        sudo 'timedatectl set-ntp true'

        sudo 'cp /etc/chrony/chrony.conf /etc/chrony/chrony.conf.bak' if test "[ -f /etc/chrony/chrony.conf ]"
        chrony_version = capture("chronyd --version | grep -o -E 'version\s*[0-9.]+' | awk '{print $2}'")

        chrony_conf = <<~CHRONY_CONF
          server ntp.aliyun.com iburst
          server cn.ntp.org.cn iburst
          server ntp.shu.edu.cn iburst
          server 0.cn.pool.ntp.org iburst
          server 1.cn.pool.ntp.org iburst
          server 2.cn.pool.ntp.org iburst
          server 3.cn.pool.ntp.org iburst
          
          keyfile /etc/chrony/chrony.keys
          driftfile /var/lib/chrony/chrony.drift
          logdir /var/log/chrony
          
          maxupdateskew 100.0
          rtcsync
          makestep 1.0 3
        CHRONY_CONF

        upload! StringIO.new(chrony_conf), '/tmp/chrony.conf'
        execute 'cat /tmp/chrony.conf | sudo tee /etc/chrony/chrony.conf'

        sudo :systemctl, 'daemon-reload'
        sudo :systemctl, 'restart', 'chrony'
        sudo :chronyc, 'makestep'
      else
        puts "ntp has already setup"
      end
      
      unless test "[ -f /etc/modules-load.d/k8s.conf ]"
        sudo 'apt -y update'
        sudo 'apt -y install ipvsadm ipset conntrack'

        k8s_mod_cfg = StringIO.new <<~K8S_MOD
          overlay
          ip_vs
          ip_vs_rr
          ip_vs_wrr
          ip_vs_lc
          ip_vs_wlc
          ip_vs_sh
          ip_vs_dh
          br_netfilter
          nf_conntrack
        K8S_MOD
        upload! k8s_mod_cfg, '/tmp/k8s-mod.conf'
        execute 'cat /tmp/k8s-mod.conf | sudo tee /etc/modules-load.d/k8s.conf'

        k8s_sysctl_cfg = StringIO.new <<~K8S_SYSCTL
          net.bridge.bridge-nf-call-ip6tables = 1
          net.bridge.bridge-nf-call-iptables = 1
          net.ipv4.ip_forward = 1
          net.ipv4.tcp_keepalive_time = 600
          net.ipv4.tcp_keepalive_intvl = 30
          net.ipv4.tcp_keepalive_probes = 10
        K8S_SYSCTL
        upload! k8s_sysctl_cfg, '/tmp/k8s-sysctl.conf'
        execute 'cat /tmp/k8s-sysctl.conf | sudo tee /etc/sysctl.d/k8s.conf'

        sudo 'sysctl --system'

        ulimit_cfg = StringIO.new <<~ULIMIT
          * soft nofile 655360
          * hard nofile 131072
          * soft nproc 655350
          * hard nproc 655350
          * soft memlock unlimited
          * hard memlock unlimited
        ULIMIT
        upload! ulimit_cfg, '/tmp/limits.conf'
        execute 'cat /tmp/limits.conf | sudo tee /etc/security/limits.conf'
        execute 'ulimit -SHn 65535'

        sudo 'sed -i -r "/(.*)swap(.*)swap(.*)/d" /etc/fstab'
        sudo 'swapoff -a'
      else
        puts "kernel optimize has already setup"
      end   
    end
  end

  desc 'etcd 192.168.64.7 ubuntu', 'setup etcd cluster for 192.168.64.7'
  option :name, :type => :string, :required => true
  option :names, :default => 'etcd01,etcd02,etcd03'
  option :clusterips, :default => '192.168.64.7,192.168.64.8,192.168.64.9'
  option :binaries_url, :type => :string, :required => true
  def etcd(hostip, username='ubuntu', port=22)
    clusterips = options[:clusterips].split(',')
    run_locally do
      execute :cfssl, 'version'

      if test "[ -d /opt/etc/cfssl/etcd ]"
        puts "\e[0;32m /opt/etc/cfssl/etcd have already exists. \e[0m\n"
      else
        execute :mkir, '-p /opt/etc/cfssl/etcd'
      end

      if test "[ -f /opt/etc/cfssl/etcd/ca-csr.json ]"
        puts "\e[0;32m /opt/etc/cfssl/etcd/ca-csr.json have already exists. \e[0m\n"
      else
        ca_csr_json = StringIO.new <<~JSON
        {
          "CN": "etcd-ca",
          "key": {
            "algo": "rsa",
            "size": 2048
          },
          "names": [
            {
              "C": "CN",
              "ST": "Guangdong",
              "L": "Shenzhen",
              "O": "k8s",
              "OU": "etcd-ca"
            }
          ],
          "ca": {
            "expiry": "87600h"
          }
        }
        JSON
        upload! ca_csr_json, '/opt/etc/cfssl/etcd/ca-csr.json'
      end

      if test "[ -f /opt/etc/cfssl/etcd/etcd-csr.json ]"
        puts "\e[0;32m /opt/etc/cfssl/etcd/etcd-csr.json have already exists. \e[0m\n"
      else
        etd_csr_json = StringIO.new <<~JSON
        {
          "CN": "etcd",
          "hosts": #{clusterips + ['127.0.0.1']},
          "key": {
            "algo": "rsa",
            "size": 2048
          },
          "names": [
            {
              "C": "CN",
              "ST": "Guangdong",
              "L": "Shenzhen",
              "O": "k8s",
              "OU": "etcd"
            }
          ]
        }
        JSON
        upload! etd_csr_json, '/opt/etc/cfssl/etcd/etcd-csr.json'
      end

      if test "[ -f /opt/etc/cfssl/etcd/ca-config.json ]"
        puts "\e[0;32m /opt/etc/cfssl/etcd/ca-config.json have already exists. \e[0m\n"
      else
        ca_config_json = StringIO.new <<~JSON
        {
          "signing": {
            "default": {
              "expiry": "87600h"
            },
            "profiles": {
              "k8s-etcd": {
                "usages": ["signing", "key encipherment", "server auth", "client auth"],
                "expiry": "87600h"
              }
            }
          }
        }
        JSON
        upload! ca_config_json, '/opt/etc/cfssl/etcd/ca-config.json'
      end

      within '/opt/etc/cfssl/etcd/' do
        if test "[ -f /opt/etc/cfssl/etcd/ca.pem ]"
          puts "\e[0;32m ignore: cfssl gencert -initca ca-csr.json | cfssljson -bare ca. \e[0m\n"
        else
          execute :cfssl, 'gencert -initca ca-csr.json | cfssljson -bare ca'
        end

        if test "[ -f /opt/etc/cfssl/etcd/etcd.pem ]"
          puts "\e[0;32m ignore: cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=k8s-etcd etcd-csr.json | cfssljson -bare etcd. \e[0m\n"
        else
          execute :cfssl, 'gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=k8s-etcd etcd-csr.json | cfssljson -bare etcd'
        end
      end
    end

    etcd_name = options[:name]
    binaries_url = options[:binaries_url]
    names = options[:names].split(',')
    initial_cluster = names.each_with_index.map {|el, i| "#{el}=https://#{clusterips[i]}:2380" }.join(',')
    on "#{username}@#{hostip}", in: :sequence, wait: 5 do
      if test "[ -f /usr/local/bin/etcd ]"
        puts "\e[0;32m /usr/local/bin/etcd has already created. \e[0m\n"
      else
        within '/tmp' do
          execute :wget, "--quiet #{binaries_url}"
          execute :tar, 'zxvf `ls | grep etcd*.tar.gz`'
          sudo :mv, "`ls | grep -v .tar.gz| grep etcd`/etcd* /usr/local/bin"
        end
      end

      if test "[ -f /etc/etcd/etcd.conf ]"
        puts "\e[0;32m /etc/etcd/etcd.conf has already created. \e[0m\n"
      else
        etcd_conf = StringIO.new <<~CONF
        ETCD_NAME="#{etcd_name}"
        ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
        ETCD_LISTEN_PEER_URLS="https://#{hostip}:2380"
        ETCD_LISTEN_CLIENT_URLS="https://#{hostip}:2379,http://127.0.0.1:2379"
        ETCD_ADVERTISE_CLIENT_URLS="https://#{hostip}:2379"
        ETCD_INITIAL_ADVERTISE_PEER_URLS="https://#{hostip}:2380"
        ETCD_INITIAL_CLUSTER="#{initial_cluster}"
        
        ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
        ETCD_INITIAL_CLUSTER_STATE="new"
        CONF

        unless test "[ -d /etc/etcd ]"
          sudo :mkdir, '-p /etc/etcd'
        end

        # puts etcd_conf.read
        upload! etcd_conf, '/tmp/etcd.conf'
        sudo :mv, '/tmp/etcd.conf /etc/etcd/'
      end

      unless test "[ -d /var/lib/etcd/default.etcd ]"
        sudo :mkdir, '-p /var/lib/etcd/default.etcd'
      end

      unless test "[ -d /etc/etcd/ssl ]"
        sudo :mkdir, '-p /etc/etcd/ssl'
      end

      files = %W[ca.csr ca-key.pem ca.pem etcd.csr etcd-key.pem etcd.pem]
      files.each do |file|
        if test "[ -f /etc/etcd/ssl/#{file} ]"
          puts "\e[0;32m /etc/etcd/ssl/#{file} has already created. \e[0m\n"
        else
          upload! "/opt/etc/cfssl/etcd/#{file}", "/tmp/#{file}"
          sudo :mv, "/tmp/#{file} /etc/etcd/ssl/"
        end
      end

      if test "[ -f /usr/lib/systemd/system/etcd.service ]"
        puts "\e[0;32m /usr/lib/systemd/system/ectd.service has already created. \e[0m\n"
      else
        etcd_service = StringIO.new <<~CONF
        [Unit]
        Description=Etcd Server
        After=network.target
        After=network-online.target
        Wants=network-online.target
        
        [Service]
        Type=notify
        EnvironmentFile=-/etc/etcd/etcd.conf
        WorkingDirectory=/var/lib/etcd/
        ExecStart=/usr/local/bin/etcd \
          --cert-file=/etc/etcd/ssl/etcd.pem \
          --key-file=/etc/etcd/ssl/etcd-key.pem \
          --trusted-ca-file=/etc/etcd/ssl/ca.pem \
          --peer-cert-file=/etc/etcd/ssl/etcd.pem \
          --peer-key-file=/etc/etcd/ssl/etcd-key.pem \
          --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \
          --peer-client-cert-auth \
          --client-cert-auth
        Restart=on-failure
        RestartSec=5
        LimitNOFILE=65536
        
        [Install]
        WantedBy=multi-user.target
        CONF

        upload! etcd_service, '/tmp/etcd.service'
        sudo :mv, '/tmp/etcd.service /usr/lib/systemd/system/'

        sudo :systemctl, 'daemon-reload'
        sudo :systemctl, 'enable etcd'
      end

      sudo :systemctl, 'restart etcd'
    end

  end

  desc 'apt 192.168.64.7 ubuntu', 'setup apt source for 192.168.64.7 via user ubuntu'
  def apt(hostip, username='ubuntu', port=22)
    on "#{username}@#{hostip}:#{port}", in: :sequence, wait: 5 do
      if test "[ -f /etc/apt/sources.list_bak ]"
        puts "/etc/apt/sources.list has already updated"
      else
        sudo :mv, '/etc/apt/sources.list', '/etc/apt/sources.list_bak'

        # mirrors_url = 'https://mirrors.ustc.edu.cn'
        mirrors_url = 'https://mirrors.tuna.tsinghua.edu.cn'  
        lsb_release_sc = capture(:lsb_release, '-sc')

        sources_list = StringIO.new <<~SOURCE_LIST
          deb #{mirrors_url}/ubuntu #{lsb_release_sc} main restricted universe multiverse
          deb-src #{mirrors_url}/ubuntu #{lsb_release_sc} main restricted universe multiverse
          
          deb #{mirrors_url}/ubuntu #{lsb_release_sc}-updates main restricted universe multiverse
          deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-updates main restricted universe multiverse
          
          deb #{mirrors_url}/ubuntu #{lsb_release_sc}-backports main restricted universe multiverse
          deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-backports main restricted universe multiverse
          
          deb #{mirrors_url}/ubuntu #{lsb_release_sc}-security main restricted universe multiverse
          deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-security main restricted universe multiverse
        SOURCE_LIST

        upload! sources_list, '/tmp/apt-sources.list'
        execute 'cat /tmp/apt-sources.list | sudo tee /etc/apt/sources.list'

        execute 'export DEBIAN_FRONTEND=noninteractive'
        sudo 'apt -y update'
        sudo 'apt -o Dpkg::Options::="--force-confold" upgrade -q -y'
        sudo 'apt -o Dpkg::Options::="--force-confold" dist-upgrade -q -y'
        sudo 'apt -y upgrade'
        sudo 'apt -y dist-upgrade'
        sudo 'apt -y autoclean'
        sudo 'apt -y full-upgrade'
        sudo 'apt -y autoremove'      
      end

      execute :echo, 'export LC_ALL=en_US.UTF-8', '>> ~/.bashrc' if test '[ -z $LC_ALL ]'
      execute :echo, 'export LANG=en_US.UTF-8', '>> ~/.bashrc' if test '[ -z $LANG ]'
    end
  end
  

  private
    def generate(template, locals={})
      context = new_binding(locals)
      CapturableERB.new(template, nil, "-", "@output_buffer").result(context)
    end
    
    def new_binding(locals)
      binding.tap do |b|
        locals.each do |name, value|
          b.local_variable_set(name, value)
        end
      end
    end

end

MacOS.start(ARGV)