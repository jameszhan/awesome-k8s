#!/usr/bin/env ruby
require 'thor'
require 'sshkit'
require 'sshkit/sudo'
require 'sshkit/dsl'

SSHKit.config.format = :pretty
SSHKit.config.output_verbosity = :debug

SUDO_USER = ENV['SUDO_USER']
SUDO_PASS = ENV['SUDO_PASS']

class Runner
  include Thor::Base

  def self.batch(&block)
    runner = Runner.new
    runner.instance_eval(&block)
    runner.execute
  end

  def initialize(config = {}, &block)
    @config = config
    instance_eval(&block) if block_given?
  end

  def scripts
    @scripts ||= []
  end

  def run(command, config = {})
    say_status :run, command, config.fetch(:verbose, true)
    scripts << command
  end

  def execute
    command = scripts.join(' && ')
    return if @config[:'dry-run']
    @config[:capture] ? `#{command}` : system(command)
  end
end

class PasswordInteractionHandler

  def on_data(command, stream_name, data, channel)
    case data
      when /password/i
        channel.send_data("#{SUDO_PASS}\n")
      else
        puts "#{command}, #{stream_name}, #{data}, #{channel}"
        channel.send_data("#{SUDO_PASS}\n")
    end
  end

end

class Awesome < Thor
  include Actions
  include SSHKit::DSL

  desc 'user k8s-node003 deploy', 'create new user deploy for k8s-node003'
  def user(hostname, username='deploy', port=22)
    target_host = SSHKit::Host.new(
      hostname: hostname,
      port: port,
      user: SUDO_USER,
      password: SUDO_PASS,
      ssh_options: {}
    )

    pass_cb = PasswordInteractionHandler.new

    on target_host, in: :sequence, wait: 5 do |host|
      if test "[ -d /home/#{username} ]"
        puts "\e[0;32m USER #{username} has already created. \e[0m\n"
      else
        sudo 'useradd -m -s /bin/bash -u 1001 deploy', interaction_handler: pass_cb
        sudo 'usermod -aG sudo deploy', interaction_handler: pass_cb
        sudo 'usermod -aG adm deploy', interaction_handler: pass_cb
        sudo 'usermod -a -G users deploy', interaction_handler: pass_cb
        sudo 'usermod -a -G staff deploy', interaction_handler: pass_cb
      end

      if test "[ -f /etc/sudoers.d/#{username} ]"
        puts "\e[0;32m USER #{username} is already NOPASSWD sudo user. \e[0m\n"
      else
        execute "echo '#{username} ALL = (ALL) NOPASSWD: ALL' > /tmp/sudoer_#{username}"
        sudo :mv, "/tmp/sudoer_#{username}", "/etc/sudoers.d/#{username}", interaction_handler: pass_cb
        sudo :chown, "-R root:root /etc/sudoers.d/#{username}", interaction_handler: pass_cb
        # execute "echo 'deploy ALL = (ALL) NOPASSWD: ALL' | sudo tee /etc/sudoers.d/deploy", interaction_handler: pass_cb
      end

      if test "[ -d /home/#{username}/.ssh ]"
        puts "\e[0;32m /home/#{username}/.ssh have already exists. \e[0m\n"
      else
        # 本地免密码 SSH 登陆
        puts "\e[0;33m /home/#{username}/.ssh not exists, create it. \e[0m\n"

        sudo "mkdir /home/#{username}/.ssh", interaction_handler: pass_cb
        upload! "/home/#{SUDO_USER}/.ssh/id_rsa.pub", '/tmp/id_rsa.pub'
        upload! "/home/#{SUDO_USER}/.ssh/id_rsa", '/tmp/id_rsa'
        upload! "/home/#{SUDO_USER}/.ssh/authorized_keys", '/tmp/authorized_keys'
        # execute "cat /tmp/id_rsa.pub | sudo tee -a /home/#{username}/.ssh/authorized_keys", interaction_handler: pass_cb

        sudo :mv, '/tmp/id_rsa.pub', "/home/#{username}/.ssh/", interaction_handler: pass_cb
        sudo :mv, '/tmp/id_rsa', "/home/#{username}/.ssh/", interaction_handler: pass_cb
        sudo :mv, '/tmp/authorized_keys', "/home/#{username}/.ssh/", interaction_handler: pass_cb

        sudo :chown, '-R', "#{username}:#{username}", "/home/#{username}/.ssh", interaction_handler: pass_cb
        sudo :chmod, '-R', 'go-rwx', "/home/#{username}/.ssh/id_rsa", interaction_handler: pass_cb
      end
    end
  end

  desc 'setup k8s-node003 deploy', 'setup for k8s-node003 via user deploy'
  def setup(hostname, user='deploy', port=22)
    on "#{user}@#{hostname}:#{port}", in: :sequence, wait: 5 do
      if test "[ -f /etc/apt/sources.list_bak ]"
        puts "/etc/apt/sources.list has already updated"
      else
        sudo :mv, '/etc/apt/sources.list', '/etc/apt/sources.list_bak'

        # mirrors_url = 'https://mirrors.ustc.edu.cn'
        mirrors_url = 'https://mirrors.tuna.tsinghua.edu.cn'
        lsb_release_sc = capture(:lsb_release, '-sc')
        if test "[ `lsb_release -si` = Ubuntu ]"
          sources_list = StringIO.new <<~SOURCE_LIST
            deb #{mirrors_url}/ubuntu #{lsb_release_sc} main restricted universe multiverse
            deb-src #{mirrors_url}/ubuntu #{lsb_release_sc} main restricted universe multiverse
            
            deb #{mirrors_url}/ubuntu #{lsb_release_sc}-updates main restricted universe multiverse
            deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-updates main restricted universe multiverse
            
            deb #{mirrors_url}/ubuntu #{lsb_release_sc}-backports main restricted universe multiverse
            deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-backports main restricted universe multiverse
            
            deb #{mirrors_url}/ubuntu #{lsb_release_sc}-security main restricted universe multiverse
            deb-src #{mirrors_url}/ubuntu #{lsb_release_sc}-security main restricted universe multiverse
          SOURCE_LIST
        elsif test "[ `lsb_release -si` = Debian ]"
          sources_list = StringIO.new <<~SOURCE_LIST
            deb #{mirrors_url}/debian #{lsb_release_sc} main
            deb-src #{mirrors_url}/debian #{lsb_release_sc} main

            deb #{mirrors_url}/debian-security #{lsb_release_sc}-security main contrib
            deb-src #{mirrors_url}/debian-security #{lsb_release_sc}-security main contrib

            deb #{mirrors_url}/debian #{lsb_release_sc}-updates main contrib
            deb-src #{mirrors_url}/debian #{lsb_release_sc}-updates main contrib
          SOURCE_LIST
        end

        if sources_list
          upload! sources_list, '/tmp/apt-sources.list'
          execute 'cat /tmp/apt-sources.list | sudo tee /etc/apt/sources.list'

          execute 'export DEBIAN_FRONTEND=noninteractive'
          sudo 'apt -y update'
          sudo 'apt -o Dpkg::Options::="--force-confold" upgrade -q -y'
          sudo 'apt -o Dpkg::Options::="--force-confold" dist-upgrade -q -y'
          sudo 'apt -y upgrade'
          sudo 'apt -y dist-upgrade'
          sudo 'apt -y autoclean'
          sudo 'apt -y full-upgrade'
          sudo 'apt -y autoremove'      
        end

        sudo :apt, 'install', '-y', 'coreutils procps libseccomp2 net-tools sysstat rsync bash-completion socat'
      end

      if test "[ -f /etc/hosts.bak ]"
        puts "/etc/hosts has already updated"
      else
        sudo :mv, '/etc/hosts', '/etc/hosts.bak'
        host_conf = StringIO.new <<~HOST_CONF
          127.0.0.1 localhost
          127.0.1.1 #{hostname}
          
          # The following lines are desirable for IPv6 capable hosts
          ::1     ip6-localhost ip6-loopback
          fe00::0 ip6-localnet
          ff00::0 ip6-mcastprefix
          ff02::1 ip6-allnodes
          ff02::2 ip6-allrouters

          192.168.1.61  k8s-master01
          192.168.1.62  k8s-master02
          192.168.1.63  k8s-master03

          192.168.1.101 k8s-node001
          192.168.1.102 k8s-node002
          192.168.1.103 k8s-node003
          192.168.1.104 k8s-node004
          192.168.1.105 k8s-node005
          192.168.1.106 k8s-node006
          192.168.1.107 k8s-node007
          192.168.1.108 k8s-node008
          192.168.1.109 k8s-node009
          192.168.1.111 k8s-node011
          192.168.1.112 k8s-node012
          192.168.1.113 k8s-node013
          192.168.1.114 k8s-node014
          192.168.1.115 k8s-node015
          192.168.1.116 k8s-node016
          192.168.1.117 k8s-node017
          192.168.1.118 k8s-node018
          192.168.1.119 k8s-node019

          192.168.1.6	  synology-ds918.local
          192.168.1.50  pve-5900hx.local
          192.168.1.60  pve-5700u.local
          192.168.1.90  ubuntu-server.local
        HOST_CONF

        upload! host_conf, '/tmp/hosts'
        execute 'cat /tmp/hosts | sudo tee /etc/hosts'
      end

      execute :echo, 'export LC_ALL=en_US.UTF-8', '> ~/.bashrc' if test '[ -z $LC_ALL ]'
      execute :echo, 'export LANG=en_US.UTF-8', '> ~/.bashrc' if test '[ -z $LANG ]'
    end
  end

  desc 'ntp k8s-node003 deploy', 'ntp k8s-node003 deploy'
  def ntp(hostname, user='deploy')
    on "#{user}@#{hostname}", in: :sequence, wait: 5 do
      unless test('type chronyd')
        sudo 'apt -y remove ntpd' if test('type ntpd')
        sudo 'apt -y update'
        sudo 'apt -y install chrony'

        sudo 'timedatectl set-timezone Asia/Shanghai'
        sudo 'timedatectl set-ntp true'

        sudo 'cp /etc/chrony/chrony.conf /etc/chrony/chrony.conf.bak' if test "[ -f /etc/chrony/chrony.conf ]"
        chrony_version = capture("chronyd --version | grep -o -E 'version\s*[0-9.]+' | awk '{print $2}'")

        chrony_conf = <<~CHRONY_CONF
          server ntp.aliyun.com iburst
          server cn.ntp.org.cn iburst
          server ntp.shu.edu.cn iburst
          server 0.cn.pool.ntp.org iburst
          server 1.cn.pool.ntp.org iburst
          server 2.cn.pool.ntp.org iburst
          server 3.cn.pool.ntp.org iburst
          
          keyfile /etc/chrony/chrony.keys
          driftfile /var/lib/chrony/chrony.drift
          logdir /var/log/chrony
          
          maxupdateskew 100.0
          rtcsync
          makestep 1.0 3
        CHRONY_CONF
  
        if chrony_version.start_with?('4.')
          chrony_conf =<<~MORE_CONF
            #{chrony_conf}
            confdir /etc/chrony/conf.d
            ntsdumpdir /var/lib/chrony
            sourcedir /run/chrony-dhcp
            sourcedir /etc/chrony/sources.d
            
            leapsectz right/UTC
          MORE_CONF
        end

        upload! StringIO.new(chrony_conf), '/tmp/chrony.conf'
        execute 'cat /tmp/chrony.conf | sudo tee /etc/chrony/chrony.conf'

        sudo :systemctl, 'daemon-reload'
        sudo :systemctl, 'restart', 'chrony'
        sudo :chronyc, 'makestep'
      else
        puts "ntp has already setup"
      end   
    end
  end

  desc 'kernel k8s-node003 deploy', 'kernel k8s-node003 deploy'
  def kernel(hostname, user='deploy')
    on "#{user}@#{hostname}", in: :sequence, wait: 5 do
      unless test "[ -f /etc/modules-load.d/k8s.conf ]"
        sudo 'apt -y update'
        sudo 'apt -y install ipvsadm ipset conntrack'

        k8s_mod_cfg = StringIO.new <<~K8S_MOD
          overlay
          ip_vs
          ip_vs_rr
          ip_vs_wrr
          ip_vs_lc
          ip_vs_wlc
          ip_vs_sh
          ip_vs_dh
          br_netfilter
          nf_conntrack
        K8S_MOD
        upload! k8s_mod_cfg, '/tmp/k8s-mod.conf'
        execute 'cat /tmp/k8s-mod.conf | sudo tee /etc/modules-load.d/k8s.conf'

        k8s_sysctl_cfg = StringIO.new <<~K8S_SYSCTL
          net.bridge.bridge-nf-call-ip6tables = 1
          net.bridge.bridge-nf-call-iptables = 1
          net.ipv4.ip_forward = 1
          net.ipv4.tcp_keepalive_time = 600
          net.ipv4.tcp_keepalive_intvl = 30
          net.ipv4.tcp_keepalive_probes = 10
        K8S_SYSCTL
        upload! k8s_sysctl_cfg, '/tmp/k8s-sysctl.conf'
        execute 'cat /tmp/k8s-sysctl.conf | sudo tee /etc/sysctl.d/k8s.conf'

        sudo 'sysctl --system'

        ulimit_cfg = StringIO.new <<~ULIMIT
          * soft nofile 655360
          * hard nofile 131072
          * soft nproc 655350
          * hard nproc 655350
          * soft memlock unlimited
          * hard memlock unlimited
        ULIMIT
        upload! ulimit_cfg, '/tmp/limits.conf'
        execute 'cat /tmp/limits.conf | sudo tee /etc/security/limits.conf'
        execute 'ulimit -SHn 65535'

        sudo 'sed -i -r "/(.*)swap(.*)swap(.*)/d" /etc/fstab'
        sudo 'swapoff -a'
      else
        puts "kernel optimize has already setup"
      end   
    end
  end

  desc 'docker k8s-node003 deploy', 'docker k8s-node003 deploy'
  def docker(hostname, user='deploy', master='slave')
    on "#{user}@#{hostname}", in: :sequence, wait: 5 do
      unless test('type containerd')
        # install docker
        execute 'sudo apt remove docker docker-engine docker.io containerd runc' if test('type docker')
        sudo 'apt -y update'
        sudo 'apt -y install ca-certificates curl gnupg lsb-release'

        lsb_release_sc = capture(:lsb_release, '-sc')
        lsb_release_si = capture(:lsb_release, '-si').downcase
        arch = capture(:dpkg, '--print-architecture')
        unless test "[ -f /usr/share/keyrings/docker-archive-keyring.gpg ]"
          # curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          # curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
          execute "curl -fsSL https://download.docker.com/linux/#{lsb_release_si}/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg"
        end
        # echo \
        # "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
        # $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        execute <<-EOS
          echo 'deb [arch=#{arch} signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/#{lsb_release_si} #{lsb_release_sc} stable' \
          | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        EOS

        sudo 'apt -y update'
        sudo 'apt -y install docker-ce docker-ce-cli containerd.io'
        daemon_json = StringIO.new <<~JSON
        {
          "data-root": "/var/lib/docker",
          "log-driver": "json-file",
          "log-opts": {
            "max-size": "200m",
            "max-file": "5"
          },
          "default-ulimits": {
            "nofile": {
              "Name": "nofile",
              "Hard": 655360,
              "Soft": 655360
            },
            "nproc": {
              "Name": "nproc",
              "Hard": 655360,
              "Soft": 655360
            }
          },
          "live-restore": true,
          "oom-score-adjust": -1000,
          "max-concurrent-downloads": 10,
          "max-concurrent-uploads": 10,
          "storage-driver": "overlay2",
          "storage-opts": [
            "overlay2.override_kernel_check=true"
          ],
          "exec-opts": [
            "native.cgroupdriver=systemd"
          ],
          "registry-mirrors": [
            "https://yssx4sxy.mirror.aliyuncs.com/"
          ],
          "insecure-registries": [
            "harbor.default.svc.cluster.local"
          ]
        }
        JSON
        upload! daemon_json, '/tmp/daemon.json'
        sudo 'mkdir /etc/docker' unless test "[ -d /etc/docker ]"
        execute 'cat /tmp/daemon.json | sudo tee /etc/docker/daemon.json > /dev/null'
      else
        puts "\e[0;32m docker have already installed. \e[0m\n"    
      end
    end
  end

  desc 'k8s 192.168.64.16 james', 'k8s 192.168.64.16 james'
  def k8s(ip, user, master='slave')
    on "#{user}@#{ip}", in: :sequence, wait: 5 do
      unless test('type docker')
        # install docker
        sudo 'apt-get remove docker docker-engine docker.io containerd runc'
        sudo 'apt-get -y update'
        sudo 'apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common'
        execute 'curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -'
        sudo 'apt-key fingerprint 0EBFCD88'
        sudo 'add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"'
        sudo 'apt-get -y update'
        sudo 'apt-get install -y docker-ce docker-ce-cli containerd.io'
        sudo 'apt-cache madison docker-ce'
        sudo 'apt-get install -y docker-ce=5:18.09.7~3-0~ubuntu-$(lsb_release -cs) docker-ce-cli=5:18.09.7~3-0~ubuntu-$(lsb_release -cs) containerd.io'
        docker_daemon = StringIO.new <<~SOURCE_CONTENT
        {
          "exec-opts": ["native.cgroupdriver=systemd"],
          "log-driver": "json-file",
          "log-opts": {
            "max-size": "100m"
          },
          "storage-driver": "overlay2"
        }
        SOURCE_CONTENT
        upload! docker_daemon, '/tmp/docker_daemon_conf'
        sudo 'mv /tmp/docker_daemon_conf /etc/docker/daemon.json'
        sudo 'mkdir -p /etc/systemd/system/docker.service.d'

        # Restart docker.
        sudo 'systemctl daemon-reload'
        sudo 'systemctl restart docker'
      end

      unless test('type kubeadm')
        sudo 'snap remove microk8s' if test('type snap')
        sudo 'apt-get -y update'
        sudo 'apt-get install -y apt-transport-https curl'
        # 74.125.206.210	packages.cloud.google.com
        execute 'curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -'
        k8s_apt_source = StringIO.new <<~EOF
          deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main
        EOF
        upload! k8s_apt_source, '/tmp/k8s_apt_source'
        sudo 'mv /tmp/k8s_apt_source /etc/apt/sources.list.d/kubernetes.list'
        sudo 'apt-get -y update'
        sudo 'apt-get install -y kubelet kubeadm kubectl'
        sudo 'apt-mark hold kubelet kubeadm kubectl'
        sudo 'kubeadm config images pull'
        sudo 'kubeadm reset --force'
        sudo 'swapoff -a'
        # if master == 'master'
        #   sudo "kubeadm init --apiserver-advertise-address #{ip} --pod-network-cidr 10.244.0.0/16 --kubernetes-version v1.15.0 --ignore-preflight-errors=all"
        #   execute 'mkdir -p $HOME/.kube'
        #   sudo 'cp -i /etc/kubernetes/admin.conf $HOME/.kube/config'
        #   sudo 'chown $(id -u):$(id -g) $HOME/.kube/config'
        #   sudo 'kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml'
        # else
        #   sudo 'kubeadm join 192.168.64.8:6443 --token zu4n0c.qipqccyqcf5p4f7s --discovery-token-ca-cert-hash sha256:e273d2cd784b8f55e6b720d1438d5ffcefdc4a8cc0fdffc0102d1402fb0b1fe4'
        # end
      end
    end
  end

  private
    def generate(template, locals={})
      context = new_binding(locals)
      CapturableERB.new(template, nil, "-", "@output_buffer").result(context)
    end
    
    def new_binding(locals)
      binding.tap do |b|
        locals.each do |name, value|
          b.local_variable_set(name, value)
        end
      end
    end

end

Awesome.start(ARGV)